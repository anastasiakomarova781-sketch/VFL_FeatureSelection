# Анализ производительности FedSDG-FS

## Почему код работает медленно?

### 1. Гомоморфное шифрование Paillier

**Проблема:** Каждая операция шифрования/расшифровки Paillier занимает **10-100 миллисекунд**

**Сравнение:**
- Обычное умножение: ~0.000001 мс (наносекунды)
- Paillier умножение: ~10-100 мс (в 10,000,000 раз медленнее!)

### 2. Тройной вложенный цикл в `compute_encrypted_statistics`

```python
for j in range(self.d):           # по признакам (12-13)
    for c in range(C):            # по классам (2)
        for i in range(n):        # по образцам (60,000!)
            # Гомоморфное умножение Paillier - ОЧЕНЬ МЕДЛЕННО
            val = enc_A[i][c] * float(self.X[i, j])
```

**Количество операций на одну итерацию:**
- Признаки активной стороны: 12
- Признаки пассивной стороны: 13
- Классы: 2
- Образцы: 60,000
- **Итого:** (12 + 13) × 2 × 60,000 = **3,000,000 операций шифрования на итерацию**

### 3. Общее количество операций

**На полном датасете с 50 итерациями:**
- 50 итераций × 2 стороны × 3,000,000 операций = **300,000,000 операций шифрования**
- При скорости 10 мс на операцию: **3,000,000 секунд = ~833 часа = ~35 дней!**

## Решения для ускорения

### Вариант 1: Уменьшить размер датасета (для тестирования)
```python
active_df = active_df.head(1000)   # 1000 образцов вместо 60,000
passive_df = passive_df.head(1000)
```
**Ускорение:** в 60 раз быстрее

### Вариант 2: Уменьшить количество итераций
```python
max_iter=5  # вместо 50
```
**Ускорение:** в 10 раз быстрее

### Вариант 3: Использовать меньший размер ключа Paillier
```python
# В fedsdg_fs_article.py изменить:
self.public_key, self.private_key = paillier.generate_paillier_keypair(n_length=512)
# вместо 1024 бит
```
**Ускорение:** в 2-3 раза быстрее (но менее безопасно)

### Вариант 4: Батчинг (обработка по частям)
Обрабатывать образцы батчами по 1000, а не все сразу

### Вариант 5: Отключить шифрование для тестирования
Создать версию без шифрования для быстрой проверки алгоритма

## Рекомендация

Для тестирования используйте:
- 1000 образцов
- 5-10 итераций
- Это займет ~5-10 минут вместо дней


